
/**
 * DNS Amplification Attack Simulator - Educational Purpose Only
 * 
 * C·∫¢NH B√ÅO QUAN TR·ªåNG:
 * - M√£ n√†y ch·ªâ d√†nh cho m·ª•c ƒë√≠ch gi√°o d·ª•c v√† nghi√™n c·ª©u b·∫£o m·∫≠t
 * - KH√îNG ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ th·ª±c hi·ªán t·∫•n c√¥ng th·ª±c t·∫ø
 * - Vi·ªác s·ª≠ d·ª•ng m√£ n√†y ƒë·ªÉ t·∫•n c√¥ng h·ªá th·ªëng th·ª±c t·∫ø l√† b·∫•t h·ª£p ph√°p
 * - Ng∆∞·ªùi d√πng ch·ªãu tr√°ch nhi·ªám ho√†n to√†n cho vi·ªác s·ª≠ d·ª•ng m√£ n√†y
 * 
 * M·ª•c ƒë√≠ch: Hi·ªÉu r√µ c√°ch th·ª©c ho·∫°t ƒë·ªông c·ªßa DNS Amplification Attack
 * ƒë·ªÉ c√≥ th·ªÉ ph√≤ng ch·ªëng hi·ªáu qu·∫£
 */

const dgram = require('dgram');
const dnsPacket = require('dns-packet');
const fs = require('fs');

class DNSAmplificationSimulator {
    constructor() {
        this.isSimulating = false;
        this.config = {
            // Danh s√°ch DNS resolvers c√¥ng khai (ch·ªâ d√πng cho simulation)
            dnsResolvers: [
                '8.8.8.8',        // Google DNS
                '1.1.1.1',        // Cloudflare DNS
                '208.67.222.222', // OpenDNS
                '9.9.9.9'         // Quad9 DNS
            ],
            dnsPort: 53,
            amplificationFactor: 0, // S·∫Ω ƒë∆∞·ª£c t√≠nh to√°n
            maxQueries: 10, // Gi·ªõi h·∫°n cho m·ª•c ƒë√≠ch gi√°o d·ª•c
            delayBetweenQueries: 1000, // 1 gi√¢y gi·ªØa c√°c query
        };

        this.logEntries = [];
        this.stats = {
            queriesSent: 0,
            responsesReceived: 0,
            totalBytesIn: 0,
            totalBytesOut: 0,
            amplificationFactors: []
        };
    }

    /**
     * T·∫°o DNS query v·ªõi lo·∫°i "ANY" ƒë·ªÉ t·ªëi ƒëa h√≥a k√≠ch th∆∞·ªõc ph·∫£n h·ªìi
     * ƒê√¢y l√† k·ªπ thu·∫≠t ch√≠nh trong DNS Amplification Attack
     */
    createAmplificationQuery(domain = 'google.com') {
        const query = {
            type: 'query',
            id: Math.floor(Math.random() * 65535),
            flags: dnsPacket.RECURSION_DESIRED,
            questions: [{
                type: 'ANY', // Y√™u c·∫ßu t·∫•t c·∫£ b·∫£n ghi DNS
                name: domain,
                class: 'IN'
            }]
        };

        return dnsPacket.encode(query);
    }

    /**
     * M√¥ ph·ªèng g·ª≠i DNS query t·ªõi DNS resolver
     * Trong t·∫•n c√¥ng th·ª±c t·∫ø, ƒë·ªãa ch·ªâ IP ngu·ªìn s·∫Ω b·ªã spoofed
     */
    async sendDNSQuery(resolver, queryBuffer, targetDomain) {
        return new Promise((resolve, reject) => {
            const client = dgram.createSocket('udp4');
            const startTime = Date.now();

            // Thi·∫øt l·∫≠p timeout
            const timeout = setTimeout(() => {
                client.close();
                reject(new Error('Query timeout'));
            }, 5000);

            client.on('message', (response, rinfo) => {
                clearTimeout(timeout);
                const endTime = Date.now();
                const responseTime = endTime - startTime;

                try {
                    const decoded = dnsPacket.decode(response);
                    const amplificationFactor = response.length / queryBuffer.length;

                    const result = {
                        resolver: resolver,
                        domain: targetDomain,
                        querySize: queryBuffer.length,
                        responseSize: response.length,
                        amplificationFactor: amplificationFactor,
                        responseTime: responseTime,
                        answers: decoded.answers || [],
                        timestamp: new Date().toISOString()
                    };

                    this.updateStats(queryBuffer.length, response.length, amplificationFactor);
                    this.logEntry('RESPONSE', result);

                    client.close();
                    resolve(result);
                } catch (error) {
                    client.close();
                    reject(error);
                }
            });

            client.on('error', (error) => {
                clearTimeout(timeout);
                client.close();
                reject(error);
            });

            // G·ª≠i query
            client.send(queryBuffer, 0, queryBuffer.length, this.config.dnsPort, resolver, (error) => {
                if (error) {
                    clearTimeout(timeout);
                    client.close();
                    reject(error);
                } else {
                    this.logEntry('QUERY', {
                        resolver: resolver,
                        domain: targetDomain,
                        querySize: queryBuffer.length,
                        timestamp: new Date().toISOString()
                    });
                }
            });
        });
    }

    /**
     * M√¥ ph·ªèng botnet g·ª≠i multiple queries
     * Trong th·ª±c t·∫ø, ƒë√¢y s·∫Ω l√† h√†ng ngh√¨n m√°y t√≠nh t·ª´ botnet
     */
    async simulateBotnetAttack(targetDomain = 'google.com', numberOfBots = 5) {
        console.log('\nüî¨ B·∫ÆT ƒê·∫¶U M√î PH·ªéNG DNS AMPLIFICATION ATTACK');
        console.log('üìö M·ª•c ƒë√≠ch: Gi√°o d·ª•c v√† nghi√™n c·ª©u b·∫£o m·∫≠t');
        console.log('‚ö†Ô∏è  C·∫¢NH B√ÅO: Kh√¥ng s·ª≠ d·ª•ng cho m·ª•c ƒë√≠ch t·∫•n c√¥ng th·ª±c t·∫ø\n');

        this.isSimulating = true;
        this.resetStats();

        console.log(`üéØ Target Domain: ${targetDomain}`);
        console.log(`ü§ñ Simulated Bots: ${numberOfBots}`);
        console.log(`üåê DNS Resolvers: ${this.config.dnsResolvers.length}`);
        console.log('\nüì° B·∫Øt ƒë·∫ßu g·ª≠i DNS queries...\n');

        const promises = [];

        for (let botId = 0; botId < numberOfBots; botId++) {
            for (let resolverIndex = 0; resolverIndex < this.config.dnsResolvers.length; resolverIndex++) {
                const resolver = this.config.dnsResolvers[resolverIndex];

                const promise = this.simulateBotQuery(botId, resolver, targetDomain, resolverIndex * 200);
                promises.push(promise);

                // Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng queries ƒë·ªÉ tr√°nh spam
                if (promises.length >= this.config.maxQueries) {
                    break;
                }
            }

            if (promises.length >= this.config.maxQueries) {
                break;
            }
        }

        try {
            const results = await Promise.allSettled(promises);
            this.analyzeResults(results);
        } catch (error) {
            console.error('‚ùå L·ªói trong qu√° tr√¨nh simulation:', error.message);
        }

        this.isSimulating = false;
        this.generateReport();
    }

    /**
     * M√¥ ph·ªèng m·ªôt bot g·ª≠i query
     */
    async simulateBotQuery(botId, resolver, domain, delay = 0) {
        return new Promise(async (resolve, reject) => {
            setTimeout(async () => {
                try {
                    const queryBuffer = this.createAmplificationQuery(domain);
                    console.log(`ü§ñ Bot-${botId} ‚Üí ${resolver}: G·ª≠i DNS ANY query cho ${domain}`);

                    const result = await this.sendDNSQuery(resolver, queryBuffer, domain);

                    console.log(`üì® Bot-${botId} ‚Üê ${resolver}: Nh·∫≠n ${result.responseSize} bytes (√ó${result.amplificationFactor.toFixed(2)})`);

                    resolve(result);
                } catch (error) {
                    console.log(`‚ùå Bot-${botId}: L·ªói khi query ${resolver} - ${error.message}`);
                    reject(error);
                }
            }, delay);
        });
    }

    /**
     * C·∫≠p nh·∫≠t th·ªëng k√™
     */
    updateStats(querySize, responseSize, amplificationFactor) {
        this.stats.queriesSent++;
        this.stats.responsesReceived++;
        this.stats.totalBytesOut += querySize;
        this.stats.totalBytesIn += responseSize;
        this.stats.amplificationFactors.push(amplificationFactor);
    }

    /**
     * Reset th·ªëng k√™
     */
    resetStats() {
        this.stats = {
            queriesSent: 0,
            responsesReceived: 0,
            totalBytesOut: 0,
            totalBytesIn: 0,
            amplificationFactors: []
        };
        this.logEntries = [];
    }

    /**
     * Ghi log entry
     */
    logEntry(type, data) {
        this.logEntries.push({
            type: type,
            timestamp: new Date().toISOString(),
            data: data
        });
    }

    /**
     * Ph√¢n t√≠ch k·∫øt qu·∫£
     */
    analyzeResults(results) {
        console.log('\nüìä PH√ÇN T√çCH K·∫æT QU·∫¢ M√î PH·ªéNG\n');

        const successful = results.filter(r => r.status === 'fulfilled');
        const failed = results.filter(r => r.status === 'rejected');

        console.log(`‚úÖ Queries th√†nh c√¥ng: ${successful.length}`);
        console.log(`‚ùå Queries th·∫•t b·∫°i: ${failed.length}`);

        if (successful.length > 0) {
            const amplificationFactors = successful.map(r => r.value.amplificationFactor);
            const avgAmplification = amplificationFactors.reduce((a, b) => a + b, 0) / amplificationFactors.length;
            const maxAmplification = Math.max(...amplificationFactors);
            const minAmplification = Math.min(...amplificationFactors);

            console.log(`\nüîç TH√îNG S·ªê KHU·∫æCH ƒê·∫†I:`);
            console.log(`   ‚Ä¢ Trung b√¨nh: ${avgAmplification.toFixed(2)}x`);
            console.log(`   ‚Ä¢ T·ªëi ƒëa: ${maxAmplification.toFixed(2)}x`);
            console.log(`   ‚Ä¢ T·ªëi thi·ªÉu: ${minAmplification.toFixed(2)}x`);

            console.log(`\nüìà TH√îNG S·ªê L∆ØU L∆Ø·ª¢NG:`);
            console.log(`   ‚Ä¢ T·ªïng bytes g·ª≠i: ${this.stats.totalBytesOut} bytes`);
            console.log(`   ‚Ä¢ T·ªïng bytes nh·∫≠n: ${this.stats.totalBytesIn} bytes`);
            console.log(`   ‚Ä¢ T·ª∑ l·ªá khu·∫øch ƒë·∫°i t·ªïng: ${(this.stats.totalBytesIn / this.stats.totalBytesOut).toFixed(2)}x`);
        }
    }

    /**
     * T·∫°o b√°o c√°o chi ti·∫øt
     */
    generateReport() {
        console.log('\nüìÑ T·∫†O B√ÅO C√ÅO CHI TI·∫æT...');

        const report = {
            simulation: {
                timestamp: new Date().toISOString(),
                purpose: 'Educational DNS Amplification Attack Simulation',
                warning: 'This simulation is for educational purposes only',
            },
            configuration: this.config,
            statistics: this.stats,
            logs: this.logEntries,
            analysis: {
                averageAmplification: this.stats.amplificationFactors.length > 0 
                    ? this.stats.amplificationFactors.reduce((a, b) => a + b, 0) / this.stats.amplificationFactors.length 
                    : 0,
                totalAmplification: this.stats.totalBytesOut > 0 
                    ? this.stats.totalBytesIn / this.stats.totalBytesOut 
                    : 0,
                effectiveness: this.stats.responsesReceived / Math.max(this.stats.queriesSent, 1) * 100
            }
        };

        const reportJson = JSON.stringify(report, null, 2);

        try {
            fs.writeFileSync('dns_amplification_simulation_report.json', reportJson);
            console.log('‚úÖ B√°o c√°o ƒë√£ ƒë∆∞·ª£c l∆∞u: dns_amplification_simulation_report.json');
        } catch (error) {
            console.log('‚ùå Kh√¥ng th·ªÉ l∆∞u b√°o c√°o:', error.message);
        }

        this.displayMitigationAdvice();
    }

    /**
     * Hi·ªÉn th·ªã l·ªùi khuy√™n v·ªÅ ph√≤ng ch·ªëng
     */
    displayMitigationAdvice() {
        console.log('\nüõ°Ô∏è  BI·ªÜN PH√ÅP PH√íNG CH·ªêNG DNS AMPLIFICATION ATTACK:\n');

        console.log('1. üîß C·∫•u h√¨nh DNS Server:');
        console.log('   ‚Ä¢ V√¥ hi·ªáu h√≥a ƒë·ªá quy m·ªü (open recursion)');
        console.log('   ‚Ä¢ H·∫°n ch·∫ø truy c·∫≠p DNS ch·ªâ cho client ƒë∆∞·ª£c ·ªßy quy·ªÅn');
        console.log('   ‚Ä¢ Tri·ªÉn khai Rate Limiting (RRL)');
        console.log('   ‚Ä¢ Ch·∫∑n ho·∫∑c h·∫°n ch·∫ø query lo·∫°i "ANY"\n');

        console.log('2. üåê C·∫•p ISP/Network:');
        console.log('   ‚Ä¢ Tri·ªÉn khai BCP 38 (Source Address Validation)');
        console.log('   ‚Ä¢ L·ªçc c√°c g√≥i tin v·ªõi IP spoofed');
        console.log('   ‚Ä¢ Gi√°m s√°t l∆∞u l∆∞·ª£ng DNS b·∫•t th∆∞·ªùng\n');

        console.log('3. üè¢ C·∫•p t·ªï ch·ª©c:');
        console.log('   ‚Ä¢ S·ª≠ d·ª•ng d·ªãch v·ª• DDoS mitigation');
        console.log('   ‚Ä¢ Tri·ªÉn khai firewall v·ªõi kh·∫£ nƒÉng ph√°t hi·ªán DDoS');
        console.log('   ‚Ä¢ X√¢y d·ª±ng k·∫ø ho·∫°ch ·ª©ng ph√≥ s·ª± c·ªë');
        console.log('   ‚Ä¢ Gi√°m s√°t bƒÉng th√¥ng v√† l∆∞u l∆∞·ª£ng m·∫°ng\n');
    }

    /**
     * Hi·ªÉn th·ªã th√¥ng tin v·ªÅ nguy√™n l√Ω ho·∫°t ƒë·ªông
     */
    displayAttackPrinciples() {
        console.log('\nüìö NGUY√äN L√ù HO·∫†T ƒê·ªòNG DNS AMPLIFICATION ATTACK:\n');

        console.log('1. üéØ M·ª•c ti√™u: T·∫•n c√¥ng t·ª´ ch·ªëi d·ªãch v·ª• (DDoS)');
        console.log('2. üîÑ C∆° ch·∫ø: Khu·∫øch ƒë·∫°i l∆∞u l∆∞·ª£ng th√¥ng qua DNS');
        console.log('3. üé≠ K·ªπ thu·∫≠t: IP Spoofing + Open DNS Resolvers');
        console.log('4. üìä Hi·ªáu qu·∫£: Truy v·∫•n nh·ªè ‚Üí Ph·∫£n h·ªìi l·ªõn\n');

        console.log('üîç C√ÅC B∆Ø·ªöC TH·ª∞C HI·ªÜN:');
        console.log('   ‚ë† K·∫ª t·∫•n c√¥ng s·ª≠ d·ª•ng botnet');
        console.log('   ‚ë° Gi·∫£ m·∫°o IP ngu·ªìn th√†nh IP n·∫°n nh√¢n');
        console.log('   ‚ë¢ G·ª≠i DNS query "ANY" t·ªõi open resolvers');
        console.log('   ‚ë£ DNS servers g·ª≠i ph·∫£n h·ªìi l·ªõn v·ªÅ IP n·∫°n nh√¢n');
        console.log('   ‚ë§ N·∫°n nh√¢n b·ªã qu√° t·∫£i b·ªüi l∆∞u l∆∞·ª£ng khu·∫øch ƒë·∫°i\n');
    }
}

// H√†m ch√≠nh ƒë·ªÉ ch·∫°y simulation
async function runSimulation() {
    const simulator = new DNSAmplificationSimulator();

    // Hi·ªÉn th·ªã th√¥ng tin gi√°o d·ª•c
    simulator.displayAttackPrinciples();

    console.log('‚ö†Ô∏è  C·∫¢NH B√ÅO PH√ÅP L√ù:');
    console.log('   ‚Ä¢ M√£ n√†y ch·ªâ d√†nh cho m·ª•c ƒë√≠ch gi√°o d·ª•c');
    console.log('   ‚Ä¢ Kh√¥ng ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ t·∫•n c√¥ng h·ªá th·ªëng th·ª±c t·∫ø');
    console.log('   ‚Ä¢ Vi·ªác t·∫•n c√¥ng m·∫°ng l√† b·∫•t h·ª£p ph√°p v√† c√≥ th·ªÉ b·ªã x·ª≠ l√Ω h√¨nh s·ª±\n');

    // Ch·∫°y simulation v·ªõi tham s·ªë gi·ªõi h·∫°n
    await simulator.simulateBotnetAttack('example.com', 3);
}

// Xu·∫•t module
module.exports = {
    DNSAmplificationSimulator,
    runSimulation
};

// Ch·∫°y simulation n·∫øu file ƒë∆∞·ª£c g·ªçi tr·ª±c ti·∫øp
if (require.main === module) {
    console.log('üéì DNS AMPLIFICATION ATTACK EDUCATIONAL SIMULATOR');
    console.log('üìñ M·ª•c ƒë√≠ch: H·ªçc t·∫≠p v√† nghi√™n c·ª©u b·∫£o m·∫≠t m·∫°ng\n');

    runSimulation().catch(error => {
        console.error('‚ùå L·ªói khi ch·∫°y simulation:', error);
    });
}
